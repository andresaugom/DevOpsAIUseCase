"""
Terraform Executor Module

Handles Terraform operations for infrastructure provisioning.
"""

import json
import logging
import subprocess
from pathlib import Path

logger = logging.getLogger(__name__)


class TerraformExecutor:
    """Executes Terraform operations for cluster provisioning"""
    
    def __init__(self, config):
        self.config = config
        self.cloud = config['cloud']
        self.terraform_dir = Path(__file__).parent.parent.parent / 'terraform' / self.cloud
        
    def provision_cluster(self):
        """Provision Kubernetes cluster using Terraform"""
        logger.info(f"Provisioning cluster on {self.cloud}...")
        
        # Initialize Terraform
        self._run_terraform_command(['init'])
        
        # Create tfvars file
        self._create_tfvars()
        
        # Plan
        self._run_terraform_command(['plan', '-out=tfplan'])
        
        # Apply
        self._run_terraform_command(['apply', '-auto-approve', 'tfplan'])
        
        # Get outputs
        outputs = self._get_outputs()
        
        return outputs
    
    def destroy_cluster(self):
        """Destroy Kubernetes cluster"""
        logger.info("Destroying cluster...")
        self._run_terraform_command(['destroy', '-auto-approve'])
    
    def _run_terraform_command(self, args):
        """Run a Terraform command"""
        cmd = ['terraform'] + args
        logger.debug(f"Running: {' '.join(cmd)}")
        
        result = subprocess.run(
            cmd,
            cwd=self.terraform_dir,
            capture_output=True,
            text=True,
            check=False  # CHANGE: Don't raise immediately
        )
        
        if result.stdout:
            logger.debug(result.stdout)
        
        # CHANGE: Log errors before raising
        if result.returncode != 0:
            logger.error(f"Terraform command failed: {' '.join(cmd)}")
            logger.error(f"STDOUT:\n{result.stdout}")
            logger.error(f"STDERR:\n{result.stderr}")
            raise subprocess.CalledProcessError(result.returncode, cmd, result.stdout, result.stderr)
        
        return result
    
    def _get_outputs(self):
        """Get Terraform outputs as JSON"""
        result = self._run_terraform_command(['output', '-json'])
        outputs_raw = json.loads(result.stdout)
        
        # Extract values from output format
        outputs = {
            key: value['value']
            for key, value in outputs_raw.items()
        }
        
        return outputs
    
    def _create_tfvars(self):
        """Create terraform.tfvars file from config
        
        Design Decision: Auto-generate terraform.tfvars
        ------------------------------------------------
        The orchestrator dynamically creates terraform.tfvars on every run to ensure:
        1. Consistency: CLI arguments directly map to Terraform variables (no config drift)
        2. Simplicity: Users configure once via CLI, not in multiple places
        3. Reproducibility: Each benchmark run has a unique cluster name with timestamp
        
        This means any existing terraform.tfvars will be OVERWRITTEN. This is intentional.
        If users need custom infrastructure, they should run Terraform manually (without
        the orchestrator), but they'll lose automated metrics collection and artifacts.
        """
        tfvars_path = self.terraform_dir / 'terraform.tfvars'
        
        if self.cloud == 'gcp':
            tfvars_content = f"""
# Auto-generated by benchmark orchestrator
project_id     = "{self.config.get('gcp_project_id', 'YOUR_PROJECT_ID')}"
region         = "{self.config.get('region', 'us-central1')}"
zone           = "{self.config.get('zone', 'us-central1-a')}"
cluster_name   = "benchmark-{self.config['run_id']}"
machine_type   = "{self.config['machine_type']}"
node_count     = {self.config['node_count']}
cpu_vendor     = "{self.config['cpu_vendor']}"
cpu_generation = "{self.config['cpu_generation']}"
"""
        elif self.cloud == 'aws':
            # TODO: Implement AWS tfvars
            raise NotImplementedError("AWS is not yet implemented")
        elif self.cloud == 'azure':
            # TODO: Implement Azure tfvars
            raise NotImplementedError("Azure is not yet implemented")
        else:
            raise ValueError(f"Unsupported cloud provider: {self.cloud}")
        
        with open(tfvars_path, 'w') as f:
            f.write(tfvars_content)
        
        logger.debug(f"Created tfvars file: {tfvars_path}")
